# CLAUDE.md

このファイルは、このリポジトリでコードを扱う際のClaude Code (claude.ai/code) への指針を提供します。

## プロジェクト概要

これはNext.jsとTypeScriptで構築されたノードグラフ可視化アプリケーションです。SVGを使用してインタラクティブな依存関係グラフをレンダリングし、複数のレイアウトアルゴリズムをサポートしています。

## コマンド

### 開発
- `npm run dev` - 開発サーバーを起動 (http://localhost:3000)
- `npm run build` - プロダクションアプリケーションをビルド
- `npm run start` - プロダクションサーバーを起動
- `npm run lint` - ESLintでコード品質チェックを実行

### 重要な注意事項
- テストフレームワークは現在設定されていません
- アプリケーションを変更する際は、コミット前に必ず `npm run lint` を実行してください

## アーキテクチャ

### コンポーネント構造
このアプリケーションはモジュラーコンポーネントアーキテクチャに従っています：

1. **NodeGraph.tsx** - メインオーケストレーターコンポーネント：
   - グラフの状態とレイアウト選択を管理
   - ノード位置に基づいて動的なviewBoxを計算
   - コンパクト/展開表示モードを処理
   - GraphNodeとGraphEdgeコンポーネントをレンダリング

2. **GraphNode.tsx** - 個別ノードコンポーネント：
   - 位置ベースのレンダリング
   - コンテンツのサイズ計算
   - ビジュアルスタイリングとインタラクティビティ

3. **GraphEdge.tsx** - 接続コンポーネント：
   - ノード間のパス計算
   - 曲線対直線エッジのレンダリング
   - 方向を示す矢印マーカー

### レイアウトシステム
`layoutAlgorithm.ts` ユーティリティは複数の配置戦略を提供：
- **階層型**: 自動レベル割り当てによるトップダウンツリーレイアウト
- **放射状**: ルートを中心とした円形レイアウト
- **力指向**: 物理ベースのスプリングレイアウト
- **自動**: グラフ構造に基づくインテリジェントな選択

### データフロー
1. `sampleGraphs.ts` でTypeScriptインターフェースを使用してサンプルグラフを定義
2. レイアウトアルゴリズムが生のグラフデータを処理して位置を割り当て
3. NodeGraphコンポーネントが配置されたノードをレンダリングしてエッジを計算
4. SVG viewBoxがすべてのコンテンツに合わせて動的に調整

### 主要なTypeScript型
- `Graph`: ノードとエッジのコレクション（オプションのメタデータ付き）
- `Node`: ID、ラベル、オプションの位置/サイズ
- `Edge`: ソースとターゲットノードID（オプションのスタイリング付き）
- `PositionedNode`: x、y座標を持つノード

## 開発パターン

### 新機能を追加する場合：
1. まず `types/graph.ts` で型を定義
2. 配置ロジックが変更される場合はレイアウトアルゴリズムを更新
3. コンポーネントを順番に修正: NodeGraph → GraphNode/GraphEdge
4. テスト用にサンプルデータを `sampleGraphs.ts` に追加

### レイアウトを変更する場合：
- レイアウトアルゴリズムは x,y 座標を持つ `PositionedNode[]` を返す
- NodeGraphの境界計算が新しい位置を処理できることを確認
- sampleGraphsからの様々なグラフ構造でテスト

### 状態管理
- グラフ選択は page.tsx で管理
- レイアウトとビューモードは NodeGraph.tsx で管理
- 外部の状態管理ライブラリは使用せず、React hooksを使用

## 基本ルール

- 日本語を第一言語として使用してください
  - ユーザーとの対話には日本語を使用すること
  - 思考中は英語を使用してもよい

- 指示に忠実に従い、指示していないことは独断で行わないでください
  - ユーザーの指定した要件や指示を最大限重視して作業を進めること
  - ユーザーの指示していないことを行う場合、必ず承認を取ってから作業を行うこと
  - 作業の進捗や問題が発生した場合は作業を一時中断し、ユーザーに指示を仰ぐこと

- 自律的な問題解決を行ってください
  - エラーや問題が発生したら、自律的に問題分析を行い解決案を提示すること
  - 複数のアプローチがある場合は、比較検討した上で推奨案を提示すること

- 既存コードを尊重してください
  - 既存のコードスタイルやパターンを尊重し、それに従うこと
  - 既存のコードを大幅に修正する場合には理由を説明し、ユーザーの承認を得ること

## コーディングガイドライン

### 一般原則

- 記述する言語の一般的なプラクティスに従った命名を行ってください
- モジュールは適切に分割し、責務が混在しないようにしてください
- エラーハンドリングを適切に実装してください
- 自己言及的なコメントを避けてください
  - 処理内容を説明するコメントは書かないでください
  - 補足的な情報が必要な箇所に、日本語でコメントを書いてください

### 関数型のコーディングプラクティス

#### 1. 純粋関数の使用

- すべての関数は、可能な限り純粋関数として定義する。
- 関数内で`Date.now()`や`Math.random()`のような、実行ごとに異なる値を返す関数は使用しない。必要な場合は、引数として渡す。
- 関数の引数オブジェクトや配列は変更しない（イミュータブルにする）。Object.assign()やスプレッド構文（...）を使って新しいオブジェクトを生成する。
- これらの規則にやむを得ず違反する場合、コメントに理由を明記する。

#### 2. イミュータブルなデータの使用

- データは一度作成したら変更しないようにすることで、予期せぬデータの変更を防ぎ、関数の予測可能性を高める。
- 変数を宣言する際は、可能な限り`const`を使用する。
- オブジェクトや配列を更新する際は、元のデータを変更せず、新しいコピーを生成する。
- `Readonly`ユーティリティなどを活用し、意図しない変更をコンパイラレベルで防止する。

```ts
interface User {
  readonly id: number;
  name: string;
}
const user: Readonly<User> = { id: 1, name: "Alice" };
// user.id = 2; // Error
```

#### 3. 高階関数とクロージャの利用

- 高階関数（関数を引数として受け取ったり、関数を返したりする関数）の使用を常に検討する。
- クロージャを利用してスコープを保持する。
- 配列の反復処理にはforループを使わず、`map`, `filter`, `reduce`などの高階関数を使用する。

### コミットのガイドライン

- 1つのコミットでは、1つの論理的な変更のみを含め、revertしやすい状態を保ってください
- 複数の変更がある場合は複数のコミットに分割してください
- コミットメッセージは日本語で記述してください

#### コミットメッセージについて

簡潔かつ明確なコミットメッセージを記述してください
内容を明確にするため、以下の文言をコミットメッセージの冒頭に含めてください

- `feat`: 機能追加 
- `fix`: バグ修正 
- `docs`: ドキュメント更新
- `style`: スタイル調整
- `refactor`: リファクタリング
- `test`: テスト追加・修正
- `chore`: 雑務的な変更

## ドキュメンテーションガイドライン

- **簡潔で端的な文章を意識する**
  - 短くわかりやすい文章で説明を行う
  - 冗長な文章で説明するよりも、マークダウンの階層構造で並列関係や包含関係を表現することを優先する
  - 文章の過度な修飾を避ける
    - 絵文字(emoji)を使用しない
    - 曖昧な表現を避け、事実と計測内容に基づいて記述する
    - 「高速」「高性能」「高品質」などの誇大表現を避ける。これらの言葉を使うときは、定量的な根拠をあわせて必ず示す

- **マークダウンを第一の選択肢とする**
  - 特段の指示がない場合は、常にマークダウン記法で記述し、`.md` 拡張子を付与して保存する

- **図を活用する**
  - 設計文書を書く場合は、できるだけ処理の流れを図示するようにする
  - アスキーアートによる作図を避け、Mermaid記法を利用すること
